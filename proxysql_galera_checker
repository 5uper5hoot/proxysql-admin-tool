#!/bin/bash
## inspired by Percona clustercheck.sh


#-------------------------------------------------------------------------------
#
# Step 1 : Bash internal configuration
#

set -o nounset    # no undefined variables

#-------------------------------------------------------------------------------
#
# Step 2 : Global variables
#

#
# Script parameters/constants
#
declare  -i DEBUG=0
readonly    PROXYSQL_ADMIN_VERSION="1.4.10"

#Timeout exists for instances where mysqld may be hung
declare  -i TIMEOUT=10

declare     RED=""
declare     NRED=""


#
# Global variables used by the script
#
declare     ERR_FILE="/dev/null"
declare     CONFIG_FILE="/etc/proxysql-admin.cnf"
declare     HOST_PRIORITY_FILE=""
declare     CHECKER_PIDFILE=""

declare -i  HOSTGROUP_WRITER_ID=1
declare -i  HOSTGROUP_READER_ID=-1
declare -i  NUMBER_WRITERS=0

declare -i  WRITER_IS_READER=0

declare     P_MODE
declare     P_PRIORITY=""

declare     MYSQL_USERNAME
declare     MYSQL_PASSWORD
declare     PROXYSQL_USERNAME
declare     PROXYSQL_PASSWORD
declare     PROXYSQL_HOSTNAME
declare     PROXYSQL_PORT

declare     PROXYSQL_DATADIR='/var/lib/proxysql'



#-------------------------------------------------------------------------------
#
# Step 3 : Helper functions
#

function log() {
  local lineno=$1
  shift

  if [[ -n $ERR_FILE ]]; then
    if [[ -n $lineno && $DEBUG -ne 0 ]]; then
      echo "[$(date +%Y-%m-%d\ %H:%M:%S)] (line $lineno) $*" >> $ERR_FILE
    else
      echo "[$(date +%Y-%m-%d\ %H:%M:%S)] $*" >> $ERR_FILE
    fi
  fi
}

function log_if_success() {
  local lineno=$1
  local rc=$2
  shift 2

  if [[ $rc -eq 0 ]]; then
    log "$lineno" "$*"
  fi
}

function error() {
  local lineno=$1
  shift

  log "$lineno" "Error: $*"
}

function warning() {
  local lineno=$1
  shift

  log "$lineno" "Warning: $*"
}

function debug() {
  if [[ $DEBUG -eq 0 ]]; then
    return
  fi

  local lineno=$1
  shift

  log "$lineno" "${RED}debug: $*${NRED}"
}

function usage () {
  local path=$0
  cat << EOF
Usage: ${path##*/} --write-hg=10 --read-hg=11 --config-file=/etc/proxysql-admin.cnf --log=/var/lib/proxysql/pxc_test_proxysql_galera_check.log

Options:
  -w, --write-hg=<NUMBER>             Specify ProxySQL write hostgroup.
  -r, --read-hg=<NUMBER>              Specify ProxySQL read hostgroup.
  -c, --config-file=PATH              Specify ProxySQL-admin configuration file.
  -l, --log=PATH                      Specify proxysql_galera_checker log file.
  -n, --writer-count=<NUMBER>         Maximum number of write hostgroup_id nodes
                                      that can be marked ONLINE
                                      When 0 (default), all nodes can be marked ONLINE
  -p, --priority=<HOST_LIST>          Can accept comma delimited list of write nodes priority
  -m, --mode=[loadbal|singlewrite]    ProxySQL read/write configuration mode,
                                      currently supporting: 'loadbal' and 'singlewrite'
                                      (default: 'singlewrite')
  -h, --help                          Display script usage information
  -v, --version                       Print version info

Notes about the mysql_servers in ProxySQL:

- NODE STATUS   * Nodes that are in status OFFLINE_HARD will not be checked
                  nor will their status be changed
                * SHUNNED nodes are not to be used with Galera based systems,
                  they will be checked and their status will be changed
                  to either ONLINE or OFFLINE_SOFT.


When no nodes were found to be in wsrep_local_state=4 (SYNCED) for either
read or write nodes, then the script will try 5 times for each node to try
to find nodes wsrep_local_state=4 (SYNCED) or wsrep_local_state=2 (DONOR/DESYNC)
EOF
}


# Check the permissions for a file or directory
#
# Globals:
#   None
#
# Arguments:
#   1: the bash test to be applied to the file
#   2: the lineno where this call is invoked (used for errors)
#   3: the path to the file
#   4: (optional) description of the path (mostly used for existence checks)
#
# Exits the script if the permissions test fails.
#
function check_permission() {
  local permission=$1
  local lineno=$2
  local path_to_check=$3
  local description=""
  if [[ $# -gt 3 ]]; then
    description="$4"
  fi

  if [ ! $permission "$path_to_check" ] ; then
    if [[ $permission == "-r" ]]; then
      error $lineno "You do not have READ permission for: $path_to_check"
    elif [[ $permission == "-w" ]]; then
      error $lineno "You do not have WRITE permission for: $path_to_check"
    elif [[ $permission == "-x" ]]; then
      error $lineno "You do not have EXECUTE permission for: $path_to_check"
    elif [[ $permission == "-e" ]]; then
      if [[ -n $description ]]; then
        error $lineno "Could not find the $description: $path_to_check"
      else
        error $lineno "Could not find: $path_to_check"
      fi
    elif [[ $permission == "-d" ]]; then
      if [[ -n $description ]]; then
        error $lineno "Could not find the $description: $path_to_check"
      else
        error $lineno "Could not find the directory: $path_to_check"
      fi
    elif [[ $permission == "-f" ]]; then
      if [[ -n $description ]]; then
        error $lineno "Could not find the $description: $path_to_check"
      else
        error $lineno "Could not find the file: $path_to_check"
      fi
    else
      error $lineno "You do not have the correct permissions for: $path_to_check"
    fi
    exit 1
  fi
}

# Executes a SQL query with the (fully) specified server
#
# Globals:
#   None
#
# Arguments:
#   1: lineno
#   2: the name of the user
#   3: the user's password
#   4: the hostname of the server
#   5: the port used to connect to the server
#   6: the query to be run
#   7: arguments to the mysql client
#   8: timeout in secs
#
function exec_sql() {
  local lineno=$1
  local user=$2
  local password=$3
  local hostname=$4
  local port=$5
  local query=$6
  local args=$7
  local timeout_secs=$8
  local retvalue
  local retoutput

  debug "$lineno" "exec_sql : $user@$hostname:$port ($args) ==> $query"

  retoutput=$(printf "[client]\nuser=${user}\npassword=\"${password}\"\nhost=${hostname}\nport=${port}"  \
      | timeout ${timeout_secs} mysql --defaults-file=/dev/stdin --protocol=tcp \
              ${args} -e "$query")
  retvalue=$?

  if [[ $DEBUG -eq 1 ]]; then
    local number_of_newlines=0
    if [[ -n $retoutput ]]; then
      number_of_newlines=$(printf "${retoutput//%/%%}" | wc -l)
    fi

    if [[  $retvalue -ne 0 ]]; then
      debug "" "--> query failed $retvalue"
    elif [[ -z $retoutput ]]; then
      debug "" "--> query returned $retvalue : <query returned no data>"
    elif [[ ${number_of_newlines} -eq 0 ]]; then
      debug "" "--> query returned $retvalue : ${retoutput}"
    else
      debug "" "--> query returned $retvalue : <data follows>"
      printf "${retoutput//%/%%}\n" | while IFS= read -r line; do
        debug "" "----> $line"
      done
    fi
  fi

  printf "${retoutput//%/%%}"
  return $retvalue
}


# Executes a SQL query on proxysql (with a timeout of $TIMEOUT seconds)
#
# Globals:
#   PROXYSQL_USERNAME
#   PROXYSQL_PASSWORD
#   PROXYSQL_HOSTNAME
#   PROXYSQL_PORT
#
# Arguments:
#   1: lineno (used for debugging/output, may be blank)
#   2: Additional arguments to the mysql client for the query
#   3: The SQL query
#
function proxysql_exec() {
  local lineno=$1
  local args=$2
  shift 2
  local query="$*"
  local retoutput

  exec_sql "$lineno" "$PROXYSQL_USERNAME" "$PROXYSQL_PASSWORD" \
           "$PROXYSQL_HOSTNAME" "$PROXYSQL_PORT" \
           "$query" "$args" "$TIMEOUT"
  retoutput=$?
  if [[ $retoutput -eq 124 ]]; then
    error $lineno "TIMEOUT: SQL query ($PROXYSQL_HOSTNAME:$PROXYSQL_PORT) : $query"
  fi
  return $retoutput
}

# Executes a SQL query on mysql (with a timeout of $TIMEOUT secs)
#
# Globals:
#   MYSQL_USERNAME
#   MYSQL_PASSWORD
#
# Arguments:
#   1: lineno (used for debugging/output, may be blank)
#   2: the hostname of the server
#   3: the port used to connect to the server
#   4: arguments to the mysql client
#   5: the query to be run
#
function mysql_exec() {
  local lineno=$1
  local hostname=$2
  local port=$3
  local args=$4
  local query=$5
  local retoutput

  exec_sql "$lineno" "$MYSQL_USERNAME" "$MYSQL_PASSWORD" \
           "$hostname" "$port" \
           "$query" "$args" "$TIMEOUT"
  retoutput=$?
  if [[ $retoutput -eq 124 ]]; then
    error $lineno "TIMEOUT: SQL query ($hostname:$$port) : $query"
  fi
  return $retoutput
}

# upgrade scheduler from old layout to new layout
#
# Globals:
#   PROXYSQL_DATADIR
#
# Arguments:
#   None
function upgrade_scheduler(){
  if [[ -f /etc/proxysql-admin.cnf ]]; then
    source /etc/proxysql-admin.cnf
  else
    error $LINENO "Assert! proxysql-admin configuration file : /etc/proxysql-admin.cnf does not exists, Terminating!"
    exit 1
  fi

  # For this function, use a shorter timeout than normal
  TIMEOUT=2

  local scheduler_rows
  scheduler_rows=$(proxysql_exec $LINENO "-Ns" "SELECT * FROM scheduler")

  for i in "${scheduler_rows[@]}"; do
    # Extract fields from the line
    local id=$(echo "$i" | awk '{print $1}')
    local s_write_hg=$(echo "$i" | awk '{print $5}')
    local s_read_hg=$(echo "$i" | awk '{print $6}')
    local s_number_of_writes=$(echo "$i" | awk '{print $7}')
    local s_log=$(echo "$i" | awk '{print $9}')
    local s_cluster_name=$(echo "$i" | awk '{print $10}')
    local s_mode=""

    # Get the mode for this cluster
    local proxysql_mode_file
    if [[ -z $s_cluster_name ]]; then
      proxysql_mode_file="${PROXYSQL_DATADIR}/mode"
    else
      proxysql_mode_file="${PROXYSQL_DATADIR}/${s_cluster_name}_mode"
    fi

    if [[ -f ${proxysql_mode_file} && -r ${proxysql_mode_file} ]] ; then
      s_mode=$(cat ${proxysql_mode_file})
    else
      error $LINENO "Cannot find the ${proxysql_mode_file} file"
    fi

    # Get the host priority file
    local s_host_priority=''
    if [[ -n $HOST_PRIORITY_FILE && -f $HOST_PRIORITY_FILE ]]; then
      debug $LINENO "Found a host priority file: %HOST_PRIORITY_FILE"
      local p_priority_hosts=""

      # Get the list of hosts from the host_priority file ignoring blanks
      # and any lines that start with '#'
      p_priority_hosts=$(cat $HOST_PRIORITY_FILE | grep ^[^#] | sed ':a;N;$!ba;s/\n/,/g')
      if [[ ! -z $p_priority_hosts ]] ; then
        s_host_priority="--priority=$p_priority_hosts"
      fi
    fi

    # Make the changes
    if [[ ! -z $s_write_hg ]] && [[ ! -z $s_read_hg ]] && [[ ! -z $s_number_of_writes ]] && [[ ! -z $s_log ]]; then
      proxysql_exec $LINENO -Ns "UPDATE scheduler SET arg1='--config-file=/etc/proxysql-admin.cnf --write-hg=$s_write_hg --read-hg=$s_read_hg --writer-count=$s_number_of_writes $s_host_priority --mode=$s_mode --log=$s_log', arg2=NULL, arg3=NULL, arg4=NULL, arg5=NULL WHERE id=$id"
      proxysql_exec $LINENO -Ns "LOAD SCHEDULER TO RUNTIME;" #" SAVE SCHEDULER TO DISK;"
    fi
  done
}


#
# Globals:
#   TIMEOUT
#
# Arguments:
#   1: lineno
#   2: hostgroup
#   3: server address
#   4: port
#   5: new status
#   6: comment
#
function change_server_status() {
  log "$1" "Changing server $2:$3:$4 to status $5. Reason: $6"
  proxysql_exec $LINENO -Ns "UPDATE mysql_servers set status = '$5' WHERE hostgroup_id = $2 AND hostname = '$3' AND port = $4;" 2>> ${ERR_FILE}
}


# Arguments:
#   The arguments to the script.
#
function parse_args() {
  local go_out=""

  # TODO: kennt, what happens if we don't have a functional getopt()?
  # Check if we have a functional getopt(1)
  if ! getopt --test; then
    go_out="$(getopt --options=w:r:c:l:n:m:p:vh --longoptions=write-hg:,read-hg:,config-file:,log:,writer-count:,mode:,priority:,version,debug,help \
    --name="$(basename "$0")" -- "$@")"
    if [[ $? -ne 0 ]]; then
      # no place to send output
      echo "Script error: getopt() failed" >&2
      exit 1
    fi
    eval set -- "$go_out"
  fi

  if [[ $go_out == " --" ]];then
    usage
    exit 1
  fi

  if echo "$go_out" | grep -q "debug"; then
    DEBUG=1

    # For now
    if [[ -t 1 ]]; then
      ERR_FILE=/dev/stdout
    fi
  fi
  
  #
  # Load the config file before reading in the command-line options
  #
  # Is there a config-file option in the command-line?
  if echo "$go_out" | grep -q "config-file"; then
    local arg_array=( "$@" )
    arg_array_len=${#arg_array[@]}
    for (( i=0; i<${arg_array_len};  i++));
    do
      if [[ "${arg_array[$i]}" == "--config-file" ]]; then
        CONFIG_FILE="${arg_array[$i+1]}"
        check_permission -e $LINENO "$CONFIG_FILE" "proxysql-admin configuration file"
        break
      fi
    done
    debug $LINENO  "--config-file specified, using : $CONFIG_FILE"
  fi
  readonly CONFIG_FILE

  if [ ! -e "$CONFIG_FILE" ]; then
      warning "" "Could not locate configuration file: $CONFIG_FILE"
  else
      check_permission -r $LINENO "$CONFIG_FILE"
      debug $LINENO "Loading $CONFIG_FILE"
      source "$CONFIG_FILE"
  fi

  for arg
  do
    case "$arg" in
      -- ) shift; break;;
      -w | --write-hg )
        HOSTGROUP_WRITER_ID="$2"
        shift 2
      ;;
      -r | --read-hg )
        HOSTGROUP_READER_ID="$2"
        shift 2
      ;;
      --config-file )
        # Do no processing of config-file here, it is processed
        # before this loop (see above)
        shift 2
      ;;
      -l | --log )
        ERR_FILE="$2"
        shift 2
        # Test if stdout and stderr are open to a terminal
        if [[ $ERR_FILE == "/dev/stderr" ]]; then
          RED=$(tput setaf 1)
          NRED=$(tput sgr0)
        fi
      ;;
      -n | --writer-count )
        NUMBER_WRITERS="$2"
        shift 2
      ;;
      -p | --priority )
        P_PRIORITY="$2"
        shift 2
      ;;
      -m | --mode )
        P_MODE="$2"
        shift 2
        if [ "$P_MODE" != "loadbal" ] && [ "$P_MODE" != "singlewrite" ]; then
          echo "ERROR: Invalid --mode passed:"
          echo "  Please choose one of these modes: loadbal, singlewrite"
          exit 1
        fi
      ;;
        --log | --version )
        echo "proxysql_galera_checker version $PROXYSQL_ADMIN_VERSION"
        exit 0
      ;;
      -h | --help )
        usage
        exit 0
      ;;
    esac
  done

  #
  # Argument validation
  #
  test $HOSTGROUP_WRITER_ID -ge 0 &> /dev/null
  if [[ $? -ne 0 ]]; then
    echo "ERROR: writer hostgroup_id is not an integer"
    usage
    exit 1
  fi

  test $HOSTGROUP_READER_ID -ge -1 &> /dev/null
  if [[ $? -ne 0 ]]; then
    echo "ERROR: reader hostgroup_id is not an integer"
    usage
    exit 1
  fi

  if [[ $NUMBER_WRITERS -lt 0 ]]; then
    echo "ERROR: The number of writers should either be 0 to enable all possible nodes ONLINE"
    echo "       or be larger than 0 to limit the number of writers"
    usage
    exit 1
  fi

  if [[ $WRITER_IS_READER -ne 0 && $WRITER_IS_READER -ne 1 ]]; then
    echo "ERROR: Writers are readers requires a boolean argument (0|1)"
    usage
    exit 1
  fi


  # With WRITER_IS_READER=1, ONLINE nodes in write hostgroup_id
  # will prefer not to be ONLINE in read hostgroup_id
  WRITER_IS_READER=1

  readonly ERR_FILE
  readonly CONFIG_FILE

  readonly HOSTGROUP_WRITER_ID
  readonly HOSTGROUP_READER_ID
  readonly NUMBER_WRITERS
  readonly WRITER_IS_READER

  readonly P_PRIORITY
  readonly P_MODE

}


# Checks to see if another instance of the script is running.
# We want only one instance of this script to be running at a time.
#
# Globals:
#   PROXYSQL_DATADIR
#   ERR_FILE
#
# Arguments:
#   1: the cluster name
#
# This function will exit if another instance of the script is running.
#
# With thanks, http://bencane.com/2015/09/22/preventing-duplicate-cron-job-executions/
#
function check_is_galera_checker_running() {
  local cluster_name=$1

  if [[ -z $cluster_name ]]; then
    CHECKER_PIDFILE=${PROXYSQL_DATADIR}/galera_checker.pid
  else
    CHECKER_PIDFILE=${PROXYSQL_DATADIR}/${cluster_name}_galera_checker.pid
  fi

  if [ -f $CHECKER_PIDFILE ] ; then
    local GPID
    GPID=$(cat $CHECKER_PIDFILE)
    if ps -p $GPID -o args=ARGS | grep $ERR_FILE | grep -o proxysql_galera_check > /dev/null 2>&1 ; then
      ps -p $GPID > /dev/null 2>&1
      if [[ $? -eq 0 ]]; then
        log "" "ProxySQL galera checker process already running."
        exit 1
      else
        echo $$ > $CHECKER_PIDFILE
        if [[ $? -ne 0 ]] ; then
          log "" "Could not create galera checker PID file"
          exit 1
        fi
      fi
    else
      log "" "Warning! Existing PID($GPID) belongs to some other process. Creating new PID file."
      echo $$ > $CHECKER_PIDFILE
      if [[ $? -ne 0 ]] ; then
        log "" "Could not create galera checker PID file"
        exit 1
      fi
    fi
  else
    echo $$ > $CHECKER_PIDFILE
    if [[ $? -ne 0 ]]; then
      log "" "Could not create galera checker PID file"
      exit 1
    fi
  fi
}


function cleanup_handler() {
  if [[ -n CHECKER_PIDFILE ]]; then
    rm -f $CHECKER_PIDFILE
  fi
}

#
# Globals:
#   TIMEOUT
#   MYSQL_USERNAME MYSQL_PASSWORD MYSQL_HOSTNAME MYSQL_PORT
#   PROXYSQL_DATADIR
#   HOSTGROUP_READER_ID HOSTGROUP_WRITER_ID
#   CONFIG_FILE
#   NUMBER_WRITERS
#
function main() {
  local cluster_name
  local mysql_credentials

  mysql_credentials=$(proxysql_exec $LINENO -Ns "SELECT variable_value FROM global_variables WHERE variable_name IN ('mysql-monitor_username','mysql-monitor_password') ORDER BY variable_name DESC")
  MYSQL_USERNAME=$(echo $mysql_credentials | awk '{print $1}')
  MYSQL_PASSWORD=$(echo $mysql_credentials | awk '{print $2}')

  cluster_name=$(proxysql_exec $LINENO -Ns \
                  "SELECT comment from scheduler where arg1 LIKE '%--write-hg=$HOSTGROUP_WRITER_ID %'")

  if [[ -z $cluster_name ]]; then
    #
    # Could not find the cluster name from the scheduler,
    # contact the cluster directly
    #
    local available_host=""
    local server port
    available_host=$(proxysql_exec $LINENO -Ns "SELECT hostname,port FROM mysql_servers where hostgroup_id in ($HOSTGROUP_WRITER_ID, $HOSTGROUP_READER_ID) and status='ONLINE' limit 1")
    server=$(echo $available_host | awk '{print $1}')
    port=$(echo $available_host | awk '{print $2}')

    cluster_name=$(mysql_exec $LINENO "$server" "$port" -Nn \
      "SELECT @@wsrep_cluster_name" 2>>${ERR_FILE}| tail -1 2>>${ERR_FILE})

    if [[ ! -z $cluster_name ]]; then
      #
      # We've found the cluster name so update the scheduler args
      #
      local arg1 my_path
      arg1=$(proxysql_exec $LINENO -Ns "SELECT arg1 from scheduler where arg1 LIKE '%--write-hg=$HOSTGROUP_WRITER_ID %'")
      my_path=$(echo ${PROXYSQL_DATADIR}/${cluster_name}_proxysql_galera_check.log | sed  's#\/#\\\/#g')
      arg1=$(echo $arg1 | sed "s/--log=.*/--log=$my_path/g")

      proxysql_exec $LINENO -Ns "UPDATE scheduler set comment='$cluster_name',arg1='$arg1' where arg1 LIKE '%--write-hg=$HOSTGROUP_WRITER_ID %';load scheduler to runtime;save scheduler to disk"
    fi
  fi

  # Check to see if there are other proxysql_galera_checkers running
  # Before we can check, we need the cluster name
  check_is_galera_checker_running "$cluster_name"

  # Check connection status to PXC nodes using monitor credentials.
  local check_monitor_user=0
  local cluster_hosts
  cluster_hosts=$(proxysql_exec $LINENO -Ns "SELECT hostname || ':' || port FROM mysql_servers WHERE comment<>'SLAVEREAD' and hostgroup_id in ($HOSTGROUP_WRITER_ID, $HOSTGROUP_READER_ID)")
  if [[ -n $cluster_hosts ]]; then
    cluster_hosts=($(echo $cluster_hosts))
  fi
  for i in "${cluster_hosts[@]}"; do
    local cluster_hostname=$(echo $i | cut -d':' -f1)
    local cluster_port=$(echo $i | cut -d':' -f2)
    local check_server_port
    check_server_port=$( mysql_exec "$LINENO" "$cluster_hostname" "$cluster_port" -Bs \
                            "select @@port")
    if [[ -n $check_server_port ]]; then
      check_monitor_user=1
      break
    fi
  done
  if [[ $check_monitor_user -ne 1 ]]; then
    log "" "Could not establish connection to PXC nodes using ProxySQL monitor credentials. Please check credentials or PXC running status."
  fi

  local mode=$MODE
  if [[ ! -z $P_MODE ]] ; then
    mode=$P_MODE
  else
    local proxysql_mode_file
    if [[ -z $cluster_name ]]; then
      proxysql_mode_file="${PROXYSQL_DATADIR}/mode"
    else
      proxysql_mode_file="${PROXYSQL_DATADIR}/${cluster_name}_mode"
    fi

    if [[ ! -f ${proxysql_mode_file} ]]; then
      local mode_check
      mode_check=$(proxysql_exec $LINENO -Ns "SELECT comment from mysql_servers where comment='WRITE' and hostgroup_id in ($HOSTGROUP_WRITER_ID, $HOSTGROUP_READER_ID)")
      if [[ "$mode_check" == "WRITE" ]]; then
        echo "singlewrite" > ${proxysql_mode_file}
      else
        echo "loadbal" > ${proxysql_mode_file}
      fi
    fi

    if [[ -r $proxysql_mode_file ]]; then
      mode=$(cat ${proxysql_mode_file})
    fi
  fi

  local reload_check_file
  if [[ -z $cluster_name ]]; then
    reload_check_file="${PROXYSQL_DATADIR}/reload"
  else
    reload_check_file="${PROXYSQL_DATADIR}/${cluster_name}_reload"
  fi
  echo "0" > ${reload_check_file}

  # Priority check
  local priority=""
  if [[ ! -z "$P_PRIORITY" ]] ; then
      priority="--priority=$P_PRIORITY"
  fi

  # Running proxysql_node_monitor script.
  # First try the same directory as this script
  local monitor_dir
  monitor_dir=$(cd $(dirname $0) && pwd)

  if [[ ! -f $monitor_dir/proxysql_node_monitor ]]; then
    # Cannot find it in same directory, try default location
    monitor_dir="/usr/bin"
    if [[ ! -f $monitor_dir/proxysql_node_monitor ]]; then
      log "" "ERROR! Could not find proxysql_node_monitor. Terminating"
      exit 1
    fi
  fi

  # Run the monitor script
  local proxysql_monitor_log
  if [[ -z $cluster_name ]]; then
    proxysql_monitor_log="${PROXYSQL_DATADIR}/proxysql_node_monitor.log"
  else
    proxysql_monitor_log="${PROXYSQL_DATADIR}/${cluster_name}_proxysql_node_monitor.log"
  fi

  local more_monitor_options=""
  if [[ $DEBUG -ne 0 ]]; then
    more_monitor_options+=" --debug "
  fi

  $monitor_dir/proxysql_node_monitor --config-file=$CONFIG_FILE \
                                     --write-hg=$HOSTGROUP_WRITER_ID \
                                     --read-hg=$HOSTGROUP_READER_ID \
                                     --mode=$mode \
                                     $priority $more_monitor_options \
                                     --log=$proxysql_monitor_log

  # print information prior to a run if ${ERR_FILE} is defined
  log "" "###### proxysql_galera_checker.sh SUMMARY ######"
  log "" "Hostgroup writers $HOSTGROUP_WRITER_ID"
  log "" "Hostgroup readers $HOSTGROUP_READER_ID"
  log "" "Number of writers $NUMBER_WRITERS"
  log "" "Writers are readers $WRITER_IS_READER"
  log "" "Log file $ERR_FILE"

  log "" "###### HANDLE WRITER NODES ######"
  local number_writers_online=0

  # TODO: kennt, is it possible to process offline nodes before online nodes?
  # This would cause unnecessary status changes, maybe we should process all online
  # nodes than process all the offline nodes?
  proxysql_exec $LINENO -Ns "SELECT hostgroup_id, hostname, port, status FROM mysql_servers WHERE hostgroup_id IN ($HOSTGROUP_WRITER_ID) AND status <> 'OFFLINE_HARD' AND comment <> 'SLAVEREAD' ORDER BY hostgroup_id, weight DESC, hostname, port" \
        | while read hostgroup server port stat || [[ -n $stat ]]
  do
    local wsrep_status
    local pxc_main_mode
    wsrep_status=$(mysql_exec $LINENO "$server" "$port" -NnsE "SHOW STATUS LIKE 'wsrep_local_state'" 2>>${ERR_FILE}| tail -1 2>>${ERR_FILE})
    pxc_main_mode=$(mysql_exec $LINENO "$server" "$port" -NnsE "SHOW VARIABLES LIKE 'pxc_maint_mode'" 2>>${ERR_FILE} | tail -1 2>>${ERR_FILE})

    # For PXC 5.6 there is no pxc_maint_mode, so assume DISABLED
    if [[ -z $pxc_main_mode ]]; then
      pxc_main_mode="DISABLED"
    fi

    log "" "--> Checking WRITE server $hostgroup:$server:$port, current status $stat, wsrep_local_state $wsrep_status"

    # we have to limit amount of writers, WSREP status OK, AND node is marked ONLINE
    # wsrep:ok  pxc:--  status:online
    if [ $NUMBER_WRITERS -gt 0 -a "${wsrep_status}" = "4" -a "$stat" == "ONLINE" ] ; then
        if [[ $number_writers_online -lt $NUMBER_WRITERS ]]; then
          number_writers_online=$(( $number_writers_online + 1 ))
          log "" "server $hostgroup:$server:$port is already ONLINE: ${number_writers_online} of ${NUMBER_WRITERS} write nodes"
        else
          number_writers_online=$(( $number_writers_online + 1 ))
          change_server_status $LINENO $HOSTGROUP_WRITER_ID "$server" $port "OFFLINE_SOFT"\
                               "max write nodes reached (${NUMBER_WRITERS})"
          echo "1" > ${reload_check_file}
        fi
    elif [[ -n $pxc_main_mode ]]; then
      # So at this point, ProxySQL and PXC are in agreement about the state of the
      # node, it's offline and is being shut down, however this node can still
      # accept writes
      # wsrep:ok  pxc:not ok  status:not online
      if [ $NUMBER_WRITERS -gt 0 -a "${wsrep_status}" = "4" -a "$stat" != "ONLINE" -a "${pxc_main_mode}" != "DISABLED" ] ; then
        number_writers_online=$(( $number_writers_online + 1 ))
        log "" "server $hostgroup:$server:$port is $stat : ${number_writers_online} of ${NUMBER_WRITERS} write nodes"
      fi
    fi

    # WSREP status OK, but node is not marked ONLINE
    # wsrep:ok  pxc:ok  status:not online
    if [ "${wsrep_status}" = "4" -a "$stat" != "ONLINE" -a "${pxc_main_mode}" == "DISABLED" ] ; then
      # we have to limit amount of writers
      if [[ $NUMBER_WRITERS -gt 0 ]] ; then
        if [[ $number_writers_online -lt $NUMBER_WRITERS ]]; then
          number_writers_online=$(( $number_writers_online + 1 ))
          change_server_status $LINENO $HOSTGROUP_WRITER_ID "$server" $port "ONLINE"\
                               "${number_writers_online} of ${NUMBER_WRITERS} write nodes"
          echo "1" > ${reload_check_file}
        else
          number_writers_online=$(( $number_writers_online + 1 ))
          if [ "$stat" != "OFFLINE_SOFT" ]; then
            change_server_status $LINENO $HOSTGROUP_WRITER_ID "$server" $port "OFFLINE_SOFT"\
                                 "max write nodes reached (${NUMBER_WRITERS})"
            echo "1" > ${reload_check_file}
          else
             log $LINENO "server $hostgroup:$server:$port is already OFFLINE_SOFT, max write nodes reached (${NUMBER_WRITERS})"
          fi
        fi
      # we do not have to limit
      elif [[ $NUMBER_WRITERS -eq 0 ]] ; then
        # TODO: kennt, What if node is SHUNNED?
        change_server_status $LINENO $HOSTGROUP_WRITER_ID "$server" $port "ONLINE"\
                             "Changed state, marking write node ONLINE"
        echo "1" > ${reload_check_file}
      fi
    fi

    # WSREP status is not ok, but the node is marked online, we should put it offline
    # wsrep:not ok  pxc:--  status:online
    if [ "${wsrep_status}" != "4" -a "$stat" = "ONLINE" ]; then
      change_server_status $LINENO $HOSTGROUP_WRITER_ID "$server" $port "OFFLINE_SOFT"\
                           "WSREP status is ${wsrep_status} which is not ok"
      echo "1" > ${reload_check_file}
    # wsrep:--  pxc:not ok  status:online
    elif [ "${pxc_main_mode}" != "DISABLED" -a "$stat" = "ONLINE" ]; then
      change_server_status $LINENO $HOSTGROUP_WRITER_ID "$server" $port "OFFLINE_SOFT"\
                           "pxc_maint_mode is $pxc_main_mode" 2>> ${ERR_FILE}
      echo "1" > ${reload_check_file}
    # wsrep:not ok  pxc:--  status:offline soft
    elif [ "${wsrep_status}" != "4" -a "$stat" = "OFFLINE_SOFT" ]; then
      log "" "server $hostgroup:$server:$port is already OFFLINE_SOFT, WSREP status is ${wsrep_status} which is not ok"
    fi
  done

  # number_writers_online is lost after loop
  number_writers_online=$(proxysql_exec $LINENO -Ns "SELECT count(*) FROM mysql_servers WHERE hostgroup_id IN ($HOSTGROUP_WRITER_ID) AND status = 'ONLINE' AND comment <> 'SLAVEREAD'" 2>>${ERR_FILE}| tail -1 2>>${ERR_FILE})

  local number_readers_online=0

  if [ ${HOSTGROUP_READER_ID} -ne -1 ]; then
    local reader_proxysql_query

    log "" "###### HANDLE READER NODES ######"
    if [ $WRITER_IS_READER -eq 1 ]; then
      reader_proxysql_query="SELECT hostgroup_id,
                                    hostname,
                                    port,
                                    status,
                                    'NULL'
                              FROM mysql_servers
                              WHERE hostgroup_id IN ($HOSTGROUP_READER_ID)
                                AND status <> 'OFFLINE_HARD'
                                AND comment <> 'SLAVEREAD'
                              ORDER BY weight DESC, hostname, port"
    elif [ $WRITER_IS_READER -eq 0 ]; then
      # We will not try to change reader state of nodes that are writer ONLINE,
      # so what we do is we ORDER BY writer.status ASC because by accident ONLINE
      # is last in the line
      reader_proxysql_query="SELECT reader.hostgroup_id,
           reader.hostname,
           reader.port,
           reader.status,
           writer.status
    FROM mysql_servers as reader
    LEFT JOIN mysql_servers as writer
      ON writer.hostgroup_id = $HOSTGROUP_WRITER_ID
      AND writer.hostname = reader.hostname
      AND writer.port = reader.port
    WHERE reader.hostgroup_id = $HOSTGROUP_READER_ID
      AND reader.status <> 'OFFLINE_HARD'
          AND reader.comment <> 'SLAVEREAD'
    ORDER BY writer.status ASC,
             reader.weight DESC,
             reader.hostname,
             reader.port"
    fi

    local offline_readers_found=0
    proxysql_exec $LINENO -Ns "$reader_proxysql_query" \
              | while read hostgroup server port stat writer_stat || [[ -n $writer_stat ]]
    do
      local wsrep_status
      local pxc_main_mode
      pxc_main_mode=$(mysql_exec $LINENO "$server" "$port" -NnsE "SHOW VARIABLES LIKE 'pxc_maint_mode'" 2>>${ERR_FILE} | tail -1 2>>${ERR_FILE})
      wsrep_status=$(mysql_exec $LINENO "$server" "$port" -NnsE "SHOW STATUS LIKE 'wsrep_local_state'" 2>>${ERR_FILE}| tail -1 2>>${ERR_FILE})

      # For PXC 5.6 there is no pxc_maint_mode, so assume DISABLED
      if [[ -z $pxc_main_mode ]]; then
        pxc_main_mode="DISABLED"
      fi

      log "" "--> Checking READ server $hostgroup:$server:$port, current status $stat, wsrep_local_state $wsrep_status"

      if [ $WRITER_IS_READER -eq 0 -a "$writer_stat" == "ONLINE" ] ; then
        if [ $offline_readers_found -eq 0 ] ; then
          # WSREP:ok  PXC:ok  STATUS:online
          if [ "${wsrep_status}" = "4" -a "$stat" == "ONLINE" -a "${pxc_main_mode}" == "DISABLED" ] ; then
            log "" "server $hostgroup:$server:$port is already ONLINE, is also write node in ONLINE state, not enough non-ONLINE readers found"
          fi

          # WSREP:ok  PXC:ok  STATUS:not online
          if [ "${wsrep_status}" = "4" -a "$stat" != "ONLINE"  -a "${pxc_main_mode}" == "DISABLED" ] ; then
            # Enable the first one found as ONLINE
            change_server_status $LINENO $HOSTGROUP_READER_ID "$server" $port "ONLINE"\
                                 "marking ONLINE write node as read ONLINE state, not enough non-ONLINE readers found"
            echo "1" > ${reload_check_file}
          # PXC:not ok  STATUS:online
          #elif [ "${pxc_main_mode}" != "DISABLED" -a "$stat" = "ONLINE" ];then
          #  change_server_status $LINENO $hostgroup "$server" $port "OFFLINE_SOFT"\
          #                       "pxc_maint_mode is $pxc_main_mode" 2>> ${ERR_FILE}
          #  echo "1" > ${reload_check_file}
          fi
        else
          # WSREP:ok  PXC:ok  STATUS:online
          if [ "${wsrep_status}" = "4" -a "$stat" == "ONLINE" -a "${pxc_main_mode}" == "DISABLED" ] ; then
            # Else disable the other READ nodes
            change_server_status $LINENO $HOSTGROUP_READER_ID "$server" $port "OFFLINE_SOFT"\
                                 "making ONLINE writer node as read OFFLINE_SOFT as well because writers should not be readers"
            echo "1" > ${reload_check_file}
          fi
          # WSREP:ok  PXC:ok  STATUS:not online
          if [ "${wsrep_status}" = "4" -a "$stat" != "ONLINE" -a "${pxc_main_mode}" == "DISABLED" ] ; then
            log "" "server $hostgroup:$server:$port is $stat, keeping node in $stat is a writer ONLINE and it's preferred not to have writers as readers"
          # PXC:not ok  STATUS:online
          #elif [ "${pxc_main_mode}" != "DISABLED" -a "$stat" = "ONLINE" ];then
          #  change_server_status $LINENO $hostgroup "$server" $port "OFFLINE_SOFT"\
          #                       "pxc_maint_mode is $pxc_main_mode" 2>> ${ERR_FILE}
          #  echo "1" > ${reload_check_file}
          fi
        fi
      else
        # WSREP:ok  PXC:ok  STATUS:online
        if [ "${wsrep_status}" = "4" -a "$stat" == "ONLINE" -a "${pxc_main_mode}" == "DISABLED" ] ; then
          log "" "server $hostgroup:$server:$port is already ONLINE"
          offline_readers_found=$(( $offline_readers_found + 1 ))
        # WSREP:ok  PXC:not ok  STATUS:not online
        elif [ "${wsrep_status}" = "4" -a "$stat" != "ONLINE" -a "${pxc_main_mode}" != "DISABLED" ] ; then
          log "" "server $hostgroup:$server:$port is $stat"
          offline_readers_found=$(( $offline_readers_found + 1 ))
        fi

        # WSREP status OK, but node is not marked ONLINE
        # WSREP:ok  PXC:ok  STATUS:not online
        if [ "${wsrep_status}" = "4" -a "$stat" != "ONLINE" -a "${pxc_main_mode}" == "DISABLED" ] ; then
          change_server_status $LINENO $HOSTGROUP_READER_ID "$server" $port "ONLINE"\
                               "changed state, making read node ONLINE"
          echo "1" > ${reload_check_file}
          offline_readers_found=$(( $offline_readers_found + 1 ))
        # PXC:not ok  STATUS:online
        #elif [ "${pxc_main_mode}" != "DISABLED" -a "$stat" = "ONLINE" ];then
        #  change_server_status $LINENO $hostgroup "$server" $port "OFFLINE_SOFT"\
        #                       "pxc_maint_mode is $pxc_main_mode" 2>> ${ERR_FILE}
        #  echo "1" > ${reload_check_file}
        fi
      fi

      # WSREP status is not ok, but the node is marked online, we should put it offline
      # WSREP:not ok  STATUS:online
      if [ "${wsrep_status}" != "4" -a "$stat" = "ONLINE" ]; then
        change_server_status $LINENO $HOSTGROUP_READER_ID "$server" $port "OFFLINE_SOFT"\
                             "WSREP status is ${wsrep_status} which is not ok"
        echo "1" > ${reload_check_file}
      # PXC:not ok  STATUS:online
      elif [ "${pxc_main_mode}" != "DISABLED" -a "$stat" = "ONLINE" ];then
        change_server_status $LINENO $HOSTGROUP_WRITER_ID "$server" $port "OFFLINE_SOFT"\
                             "pxc_maint_mode is $pxc_main_mode" 2>> ${ERR_FILE}
        echo "1" > ${reload_check_file}
      # WSREP:not ok  STATUS:offline soft
      elif [ "${wsrep_status}" != "4" -a "$stat" = "OFFLINE_SOFT" ]; then
        log "" "server $hostgroup:$server:$port is already OFFLINE_SOFT, WSREP status is ${wsrep_status} which is not ok"
      fi
    done

    number_readers_online=$(proxysql_exec $LINENO -Ns "SELECT count(*) FROM mysql_servers WHERE hostgroup_id IN ($HOSTGROUP_READER_ID) AND status = 'ONLINE' AND comment <> 'SLAVEREAD'" 2>>${ERR_FILE}| tail -1 2>>${ERR_FILE})
  fi

  log "" "###### SUMMARY ######"
  log "" "--> Number of writers that are 'ONLINE': ${number_writers_online} : hostgroup: ${HOSTGROUP_WRITER_ID}"
  [[ ${HOSTGROUP_READER_ID} -ne -1 ]] && log "" "--> Number of readers that are 'ONLINE': ${number_readers_online} : hostgroup: ${HOSTGROUP_READER_ID}"


  # TODO: kennt, should this check be [[ $number_of_writers_online -ne $NUMBER_WRITERS ]] ??
  # In other words, the number of writers doesn't match (or are we just checking for 0)

  cnt=0
  # We don't have any writers... alert, try to bring some online!
  # This includes bringing a DONOR online
  if [[ ${number_writers_online} -eq 0 ]]; then
    log "" "###### TRYING TO FIX MISSING WRITERS ######"
    log "" "No writers found, Trying to enable last available node of the cluster (in Donor/Desync state)"
    proxysql_exec $LINENO -Ns "SELECT hostgroup_id, hostname, port, status FROM mysql_servers WHERE hostgroup_id IN ($HOSTGROUP_WRITER_ID) AND status <> 'OFFLINE_HARD' AND comment <> 'SLAVEREAD'" \
     | while read hostgroup server port stat || [[ -n $stat ]]
    do
      safety_cnt=0
      while [ ${cnt} -le $NUMBER_WRITERS -a ${safety_cnt} -lt 5 ]
        do
          local wsrep_status
          wsrep_status=$(mysql_exec $LINENO "$server" "$port" -NnsE "SHOW STATUS LIKE 'wsrep_local_state'" 2>>${ERR_FILE} | tail -1 2>>${ERR_FILE})
          log "" "Check server $hostgroup:$server:$port for only available node in DONOR state, status $stat , wsrep_local_state $wsrep_status"
          if [ "${wsrep_status}" = "2" -a "$stat" != "ONLINE" ]; then
           # if we are on Donor/Desync an not online in mysql_servers -> proceed
            PROXY_RUNTIME_STATUS=$(proxysql_exec $LINENO -Ns "SELECT status FROM runtime_mysql_servers WHERE hostname='${server}' AND port='${port}' AND hostgroup_id='${hostgroup}'")
            if [ "${PROXY_RUNTIME_STATUS}" != "ONLINE" ]; then
              # if we are not online in runtime_mysql_servers, proceed to change
              # the server status and reload mysql_servers
              change_server_status $LINENO $HOSTGROUP_WRITER_ID "$server" $port "ONLINE"\
                                   "WSREP status is DESYNC/DONOR, as this is the only node we will put this one online"
              echo "1" > ${reload_check_file}
              cnt=$(( $cnt + 1 ))
            else
              # TODO: kennt, do we really want to remove the reload_check_file?
              # What happens to the other changes?

              # otherwise (we are already ONLINE in runtime_mysql_servers)
              # no need to reload so let's just remove reload_check_file
              # and update it to ONLINE in mysql_servers (in case something would reload it)
              rm ${reload_check_file}
              cnt=$(( $cnt + 1 ))
              change_server_status $LINENO $HOSTGROUP_WRITER_ID "$server" $port "ONLINE"\
                                   "WSREP status is DESYNC/DONOR, as this is the only node we will put this one online"
            fi
          fi
          safety_cnt=$(( $safety_cnt + 1 ))
      done
    done
  fi

  local cnt=0
  # We don't have any readers... alert, try to bring some online!
  if [[  ${HOSTGROUP_READER_ID} -ne -1 && ${number_readers_online} -eq 0 ]]; then
    log "" "###### TRYING TO FIX MISSING READERS ######"
    log "" "--> No readers found, Trying to enable last available node of the cluster (in Donor/Desync state) or pick the master"
    proxysql_exec $LINENO -Ns "SELECT hostgroup_id, hostname, port, status FROM mysql_servers WHERE hostgroup_id IN ($HOSTGROUP_READER_ID) AND status <> 'OFFLINE_HARD' AND comment <> 'SLAVEREAD'" | while read hostgroup server port stat || [[ -n $stat ]]
    do
      local safety_cnt=0
        while [[ ${cnt} -eq 0 && ${safety_cnt} -lt 5 ]]
        do
          local wsrep_status
          wsrep_status=$(mysql_exec $LINENO "$server" "$port" -NnsE "SHOW STATUS LIKE 'wsrep_local_state'" 2>>${ERR_FILE} | tail -1 2>>${ERR_FILE})
          log "" "Check server $hostgroup:$server:$port for only available node in DONOR state, status $stat , wsrep_local_state $wsrep_status"
          if [ "${wsrep_status}" = "2" -a "$stat" != "ONLINE" ];then
            # if we are on Donor/Desync an not online in mysql_servers -> proceed
            PROXY_RUNTIME_STATUS=$(proxysql_exec $LINENO -Ns "SELECT status FROM runtime_mysql_servers WHERE hostname='${server}' AND port='${port}' AND hostgroup_id='${hostgroup}'")
            if [ "${PROXY_RUNTIME_STATUS}" != "ONLINE" ]; then
              # if we are not online in runtime_mysql_servers,
              # proceed to change the server status and reload mysql_servers
              change_server_status $LINENO $HOSTGROUP_READER_ID "$server" $port "ONLINE"\
                                   "WSREP status is DESYNC/DONOR, as this is the only node we will put this one online"
              echo "1" > ${reload_check_file}
              cnt=$(( $cnt + 1 ))
            else
              # TODO: kennt, do we really want to remove the reload_check_file?
              # What happens to the other changes?

              # otherwise (we are already ONLINE in runtime_mysql_servers)
              # no need to reload so let's just remove reload_check_file and
              # update it to ONLINE in mysql_servers (in case something would reload it)
              rm ${reload_check_file}
              cnt=$(( $cnt + 1 ))
              change_server_status $LINENO $HOSTGROUP_READER_ID "$server" $port "ONLINE"\
                                   "WSREP status is DESYNC/DONOR, as this is the only node we will put this one online"
            fi
          fi
          safety_cnt=$(( $safety_cnt + 1 ))
      done
    done

    local check_slave
    local is_query_rule_active
    check_slave=$(proxysql_exec $LINENO -Ns "SELECT hostname FROM mysql_servers WHERE comment='SLAVEREAD' AND status='ONLINE'" 2>>${ERR_FILE}| tail -1 2>>${ERR_FILE})
    is_query_rule_active=$(proxysql_exec $LINENO -Ns "SELECT active FROM mysql_query_rules WHERE destination_hostgroup=$HOSTGROUP_READER_ID limit 1;" 2>> ${ERR_FILE} | tail -1 2>>${ERR_FILE})
    if [[ -n $is_query_rule_active ]]; then
      if [ "$mode" == "singlewrite" ]; then
        if [[ -z ${check_slave} ]]; then
          if [[ ${is_query_rule_active} -eq 1 ]]; then
            proxysql_exec $LINENO -Ns "UPDATE mysql_query_rules SET active=0 WHERE destination_hostgroup=$HOSTGROUP_READER_ID;" 2>> ${ERR_FILE}
            proxysql_exec $LINENO -Ns "LOAD MYSQL QUERY RULES TO RUNTIME;SAVE MYSQL QUERY RULES TO DISK;" 2>> ${ERR_FILE}
            # TODO: kennt, this has nothing to do with marking the writer as read/write
            log "" "No readers found, marking single writer node as read/write mode"
          fi
        else
          if [[ ${is_query_rule_active} -eq 0 ]]; then
          # TODO: kennt, do we really want to do this?
          # What if someone manually disabled the rule on purpose?
            proxysql_exec $LINENO -Ns "UPDATE mysql_query_rules SET active=1 WHERE destination_hostgroup=$HOSTGROUP_READER_ID;" 2>> ${ERR_FILE}
            proxysql_exec $LINENO -Ns "LOAD MYSQL QUERY RULES TO RUNTIME;SAVE MYSQL QUERY RULES TO DISK;" 2>> ${ERR_FILE}
            # TODO: kennt, this is enabling, not disabling read transactions
            # (of course, it's true in a sense since, but since we don't know
            # the contents of the rules...)
            log "" "Slave host is online, disabling read transaction from writer node"
          fi
        fi
      fi
    fi

  fi

  if [ "$mode" == "singlewrite" ]; then
    if [[  ${HOSTGROUP_READER_ID} -ne -1 && ${number_readers_online} -gt 0 ]]; then
      local is_query_rule_active
      is_query_rule_active=$(proxysql_exec $LINENO -Ns "SELECT active FROM mysql_query_rules WHERE destination_hostgroup=$HOSTGROUP_READER_ID limit 1;" 2>> ${ERR_FILE} | tail -1 2>>${ERR_FILE})
      if [[ -n $is_query_rule_active ]]; then
        if [[ ${is_query_rule_active} -eq 0 ]]; then
          # TODO: kennt, do we really want to do this?
          # What if someone manually disabled the rule on purpose?
          proxysql_exec $LINENO -Ns "UPDATE mysql_query_rules SET active=1 WHERE destination_hostgroup=$HOSTGROUP_READER_ID;" 2>> ${ERR_FILE}
          proxysql_exec $LINENO -Ns "LOAD MYSQL QUERY RULES TO RUNTIME;SAVE MYSQL QUERY RULES TO DISK;" 2>> ${ERR_FILE}
          # TODO: kennt, what does this log mean?  We are just re-enabling the rules for the read hostgroup
          log "" "Found reader, disabling read transaction from writer node"
        fi
      fi
    fi
  fi


  # TODO: kennt, is there a reason why this file is needed for this?
  # We don't need to save to disk?
  # Can't we just keep a global variable around for this?
  if [[ $(cat ${reload_check_file}) -ne 0 ]] ; then
      log "" "###### Loading mysql_servers config into runtime ######"
      proxysql_exec $LINENO -Ns "LOAD MYSQL SERVERS TO RUNTIME;" 2>> ${ERR_FILE}
  else
      log "" "###### Not loading mysql_servers, no change needed ######"
  fi

  rm -f $CHECKER_PIDFILE
  CHECKER_PIDFILE=""
}


#-------------------------------------------------------------------------------
#
# Step 4 : Begin script execution
#

#
# In the initial version, ProxySQL has 5 slots for command-line arguments
# and would send them separately (each enclosed in double quotes,
# such as "arg1" "arg2" etc..).
#
# We now configure all parameters in the arg1 field (since we need more
# than 5 arguments).  This means that we now receive all the arguments
# in one parameter "arg1 arg2 arg3 arg4 arg5"
#
# This means that anytime this script is called with > 1 argument, we
# assume that the old method is in use and we need to upgrade the script
# to the new method (in upgrade_scheduler).
#

if [ "$#" -eq 1 ]; then
  # Below set will reshuffle parameters.
  # example arg1=" --one=1 --two=2" will result in:
  # $1 = --one=1
  # $2 = --two=2
  #
  set -- $1
else
  echo "Old config detected...trying to upgrade More than one parameter"

  if [[ "$@" =~ --debug ]]; then
    DEBUG=1

    # For now
    if [[ -t 1 ]]; then
      ERR_FILE=/dev/stderr
    fi
  fi

  upgrade_scheduler
  exit 1
fi

trap cleanup_handler EXIT

parse_args "$@"
main

exit 0
